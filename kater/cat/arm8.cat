// Standard preamble: various combinations that are invalid

assume [W] ; [R] = 0
assume [F] ; [R] = 0
assume [F] ; [W] = 0
assume [F] ; mo_imm = 0
assume [F] ; rf = 0
assume [F] ; rf_inv = 0
assume mo_imm ; [F] = 0
assume rf ; [F] = 0
assume rf_inv ; [F] = 0
assume [REL] ; [SC] = 0
assume [ACQ] ; [SC] = 0

let dmb.full = DMB_SY
let dmb.ld = DMB_LD
let dmb.st = DMB_ST

// Definition of standard relations
let po = po_imm+
let co = mo_imm+
let fr = rf_inv ; co | fr_init ; co*
let ctrl = ctrl_imm ; po_imm*

// Atomic RMW relation
let rmw = lxsx | amo

// Local read successor
// let lrs = [W]; (po-loc \ (po-loc;[W];po-loc)) ; [R]

// Dependency ordering
let dob = addr | data
	| ctrl; [W]
	| (ctrl | (addr; po)); [ISB] | [ISB]; po //; [R]
	| addr; po; [W]
	| (addr | data); lrs

// Atomic ordering
let aob = rmw
	| [range_rmw]; lrs; [A | Q]

// Barrier ordering
let bob = po; [dmb.full]; po
        | po; ([A];amo;[L]); po
	| [L]; po; [A]
	| [R_ret]; po; [dmb.ld]; po
	| [A | Q]; po
	| [W]; po; [dmb.st]; po; [W]
	| po; [L]

save ppo = reduce (dob | aob | bob)+

acyclic (rfe | co | fr | ppo)

