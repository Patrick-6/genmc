%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.2"

// %define api.token.raw
%define api.token.constructor
%define api.token.prefix {TOK_}
%define api.value.type variant
%define parse.assert
%define parse.trace
// %define parse.error detailed
%define parse.error verbose
// %define parse.lac full
%locations

%code requires {
  #include <string>
  #include "RegExp.hpp"
  class Driver;
}

%param { Driver& drv }

%code {
  #include <iostream>
  #include <memory>
  #include <unordered_map>
  #include <vector>
  #include "RegExp.hpp"
  #include "Driver.hpp"
}


%token
  LET	   "let"
  ACYCLIC  "acyclic"
  PROPERTY "property"
  ZERO     "0"
  EQ       "="
  SEMI     ";"
  ALT      "|"
  PLUS     "+"
  STAR     "*"
  QMARK    "?"
  LPAREN   "("
  RPAREN   ")"
  LBRACK   "["
  RBRACK   "]"
;

%token YYEOF 0

%token <std::string> ID;
%nterm <std::unique_ptr<RegExp>> rel;

%left  "|"
%left  ";"
%precedence "+" "*" "?"

%printer { yyo << *($$); } <std::unique_ptr<RegExp>>;
%printer { yyo << $$; } <*>;

%start main
%%

main:	  %empty		{ }
	| main decl		{ }
        ;

decl:	  "let" ID "=" rel		{ drv.variables[$2] = std::move($4); }
	| "property" rel "=" "0" 	{ drv.register_emptiness_assumption(std::move(optimizeRE(std::move($2)))); }
	| "acyclic" rel 		{ drv.acyclicity_constraints.push_back(std::move($2)); }
	;

rel:	  "(" rel ")"		{ $$ = std::move($2); }
	| "[" rel "]"		{ $$ = make_BracketRE(std::move($2)); }
	| rel "|" rel		{ $$ = make_AltRE(std::move($1), std::move($3)); }
	| rel ";" rel		{ $$ = make_SeqRE(std::move($1), std::move($3)); }
	| rel "*"		{ $$ = make_StarRE(std::move($1)); }
	| rel "+"		{ $$ = make_PlusRE(std::move($1)); }
	| rel "?"		{ $$ = make_QMarkRE(std::move($1)); }
   	| ID			{ auto it = drv.variables.find($1);
				  $$ = (it == drv.variables.end()) ? make_CharRE($1) : it->second->clone(); }
	;

%%

void yy::parser::error (const location_type& l, const std::string& m)
{
	std::cerr << "\n" << l << ": " << m << "\n";
}
